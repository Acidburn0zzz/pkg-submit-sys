#!/usr/bin/env bash

err() {
  local mesg="$1"; shift
  printf " (remote) \033[1;31merror:\033[0;0m ${mesg}\n" "$@" >&2
}

msg() {
  local mesg="$1"; shift
  printf " (remote) \033[1;32m***\033[0;0m ${mesg}\n" "$@"
}

die() {
  err "$@"
  exit 1
}

source "$HOME/admin/config" || die "failed to read configuration"

user="$1"

cleanup() {
  if [[ -n "$path" ]]; then
    rm -rf "$path"
  fi
  exit 1
}

install -dm755 "${HOME}/uploads" \
  || die "failed to create uploads directory"
install -dm755 "${HOME}/uploads/${user}" \
  || die "failed to create user's upload directory"

# when the client disconnects our parent dies and we recieve this signal
# so start the cleanup process
trap cleanup SIGHUP SIGTERM SIGINT

template="${HOME}/uploads/${user}/XXXXXXXX"
path=$(mktemp -d "${template}")
if (( $? != 0 )); then
  err "failed to create directory"
  exit 1
fi


msg "receiving files..."
bsdtar -C "${path}" -xvf - <&0 &
pid=$!
exec 0>&-
wait "${pid}"
if (( $? != 0 )); then
  err "failed to unpack received data"
  cleanup
  exit 1
fi

bail() {
  err "$@"
  cleanup
}

cd "${path}" || bail "failed to change to package directory"

repo_exists() {
  local repo="$1"
  if [[ ! -d "${repo_base}/${repo}/os" ]]; then
    err "no such repository: %s" "${repo}"
    false
  else
    true
  fi
}

check_access() {
  # currently we don't have such fine access controls
  :
}

push_package_to() {
  local arch="$1"
  local repo="$2"
  local file="$3"
  local pkgname="$4"
  local pkgver="$5"

  local dest="${repo_base}/${repo}/os/${arch}"
  local db="${dest}/${repo}.db.tar.gz"

  # The repository database must exist
  if [[ ! -d "${dest}" || ! -e "${db}" ]]; then
    err "Found no repo database for repository %s at: %s" "${repo}" "${db}"
    return 1
  fi

  # A file of the same name and version must not exist
  if [[ -e "${dest}/${file}" ]]; then
    err "Package %s already exists in %s-[%s] (same version)" "${pkgname}" "${arch}" "${repo}"
    return 1
  fi

  # Push!
  if ! cp "${file}" "${file}.sig" "${dest}"; then
    err "Failed to copy package files: ${file}"
    return 1
  fi

  # Go to the repo dir
  if ! pushd "${dest}" > /dev/null; then
    err "Failed to change to repository-directory"
    return 1
  fi

  # Add the package
  if ! repo-add -f "${repo}.db.tar.gz" "${file}"; then
    err "Failed to add package to repository"
    popd > /dev/null || bail "Failed to go back to previous directory"
    return 1
  fi

  # Remove older packages
  for i in "${pkgname}"-*.pkg.tar.xz; do
    case "$i" in
      $file) : ;;
      ${pkgname}-[0-9]*.pkg.tar.xz)
        msg "Removing old version of %s" "${pkgname}"
        rm -f "${i}" "${i}.sig"
        ;;
    esac
  done

  popd > /dev/null || bail "Failed to go back to previous directory"
}

push_package() {
  local repo="$1"
  local pkg="$2"

  local pkgname="${pkg%%-[0-9]*}"
  local archend="${pkg##*-}"
  local arch="${archend%%.*}"

  local verend="${pkg#${pkgname}-}"
  local pkgver="${verend%-${arch}*}"

  msg "package: %s version %s for architecture %s" "${pkgname}" "${pkgver}" "${arch}"
  # check for an existing package
  local args=("${repo}" "${pkg}" "${pkgname}" "${pkgver}")
  case "${arch}" in
    i686|x86_64)
      push_package_to "${arch}" "${args[@]}"
      ;;
    any)
      for i in i686 x86_64; do
        push_package_to "${i}" "${args[@]}"
      done
      ;;
  esac
}

msg "Pushing packages..."
for repo in *; do
  if ! repo_exists "${repo}"; then
    continue;
  fi
  if ! check_access "${repo}"; then
    continue;
  fi

  if pushd "${repo}" >/dev/null; then
    for pkg in *.pkg.tar.xz; do
      push_package "${repo}" "${pkg}"
    done
    popd >/dev/null || bail "failed to enter previous directory"
  fi
done

msg "Functionality not implemented yet"
cleanup

# vim: set ts=2 sts=2 sw=2 et:
