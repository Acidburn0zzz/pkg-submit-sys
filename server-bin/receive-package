#!/usr/bin/env bash

err() {
  local mesg="$1"; shift
  printf " (remote) \033[1;31merror:\033[0;0m ${mesg}\n" "$@" >&2
}

wrn() {
  local mesg="$1"; shift
  printf " (remote) \033[1;33m---\033[0;0m ${mesg}\n" "$@"
  printf "\033[1;33m---:\033[0;0m ${mesg}\n" "$@" \
    >> "${path}/warnings"
}

msg() {
  local mesg="$1"; shift
  printf " (remote) \033[1;32m***\033[0;0m ${mesg}\n" "$@"
}

die() {
  err "$@"
  exit 1
}

source "$HOME/admin/config" || die "failed to read configuration"

user="$1"

cleanup() {
  if [[ -n "$path" ]]; then
    rm -rf "$path"
  fi
  exit 1
}

install -dm755 "${HOME}/uploads" \
  || die "failed to create uploads directory"
install -dm755 "${HOME}/uploads/${user}" \
  || die "failed to create user's upload directory"

# when the client disconnects our parent dies and we recieve this signal
# so start the cleanup process
trap cleanup SIGHUP SIGTERM SIGINT

template="${HOME}/uploads/${user}/XXXXXXXX"
path=$(mktemp -d "${template}")
if (( $? != 0 )); then
  err "failed to create directory"
  exit 1
fi

send_progress() {
  while : ; do
    du -sk "${path}" | awk '{print 1024 * $1}'
    sleep 1
  done
}

msg "receiving files..."
# 2> >(tail) to buffer bsdtar's 'x' output as it flushes without
# \n when starting a file, and prints \n at the end of the file
bsdtar -C "${path}" -xvf - <&0 2> >(tail -f) &
pid=$!
exec 0>&-
send_progress &
progress=$!
wait "${pid}"
if (( $? != 0 )); then
  err "failed to unpack received data"
  cleanup
  exit 1
fi
kill "${progress}" 2>/dev/null
wait "${progress}"

bail() {
  err "$@"
  cleanup
}

cd "${path}" || bail "failed to change to package directory"

repo_exists() {
  local repo="$1"
  if [[ ! -d "${repo_base}/${repo}/os" ]]; then
    err "no such repository: %s" "${repo}"
    false
  else
    true
  fi
}

check_access() {
  # currently we don't have such fine access controls
  :
}

push_package_to() {
  local arch="$1"
  local repo="$2"
  local file="$3"
  local pkgname="$4"
  local pkgver="$5"

  local dest="${repo_base}/${repo}/os/${arch}"
  local db="${dest}/${repo}.db.tar.gz"

  msg "starting with %s for architecture %s" "${pkgname}" "${arch}"

  # The repository database must exist
  if [[ ! -d "${dest}" || ! -e "${db}" ]]; then
    wrn "Found no repo database for repository %s at: %s" "${repo}" "${db}"
    return 1
  fi

  # A file of the same name and version must not exist
  if [[ -e "${dest}/${file}" ]]; then
    wrn "Package %s already exists in %s-[%s] (same version)" "${pkgname}" "${arch}" "${repo}"
    #return 1
  fi

  # Push!
  if ! cp "${file}" "${file}.sig" "${dest}"; then
    err "Failed to copy package files: ${file}"
    return 1
  fi

  # Go to the repo dir
  if ! pushd "${dest}" > /dev/null; then
    err "Failed to change to repository-directory"
    return 1
  fi

  # Add the package
  if ! repo-add -f "${repo}.db.tar.gz" "${file}"; then
    err "Failed to add package to repository"
    popd > /dev/null || bail "Failed to go back to previous directory"
    return 1
  fi

  # Remove older packages
  for i in "${pkgname}"-*.pkg.tar.xz; do
    case "$i" in
      $file) : ;;
      ${pkgname}-[0-9]*.pkg.tar.xz)
        msg "Removing old version of %s" "${pkgname}"
        rm -f "${i}" "${i}.sig"
        ;;
    esac
  done

  popd > /dev/null || bail "Failed to go back to previous directory"

  msg "finished with %s for architecture %s" "${pkgname}" "${arch}"
}

push_package() {
  local repo="$1"
  local pkg="$2"

  local pkgname="${pkg%%-[0-9]*}"
  local archend="${pkg##*-}"
  local arch="${archend%%.*}"

  local verend="${pkg#${pkgname}-}"
  local pkgver="${verend%-${arch}*}"

  msg "package: %s version %s for architecture %s" "${pkgname}" "${pkgver}" "${arch}"
  # we use these args multiple times :P
  local args=("${repo}" "${pkg}" "${pkgname}" "${pkgver}")

  # push to either the package's arch, or all of them on 'any'
  case "${arch}" in
    i686|x86_64)
      push_package_to "${arch}" "${args[@]}"
      ;;
    any)
      for i in i686 x86_64; do
        push_package_to "${i}" "${args[@]}"
      done
      ;;
  esac
}

msg "Pushing packages..."
for repo in *; do
  if ! repo_exists "${repo}"; then
    continue;
  fi
  if ! check_access "${repo}"; then
    continue;
  fi

  if pushd "${repo}" >/dev/null; then
    for pkg in *.pkg.tar.xz; do
      push_package "${repo}" "${pkg}"
    done
    popd >/dev/null || bail "failed to enter previous directory"
  fi
done

if [[ -e "${path}/warnings" ]]; then
  msg "Repeating all warnings for you at the end now:"
  cat "${path}/warnings"
fi
msg "Thanks for your contribution."
cleanup

# vim: set ts=2 sts=2 sw=2 et:
