#!/usr/bin/env bash

err() {
  local mesg="$1"; shift
  printf " (remote) \033[1;31merror:\033[0;0m ${mesg}\n" "$@" >&2
  exit 1
}

msg() {
  local mesg="$1"; shift
  printf " (remote) \033[1;32m***\033[0;0m ${mesg}\n" "$@"
}

die() {
  err "$@"
  exit 1
}

source "$HOME/admin/config" || die "failed to read configuration"

user="$1"

cleanup() {
  if [[ -n "$path" ]]; then
    rm -rf "$path"
  fi
  exit 1
}

install -dm755 "${HOME}/uploads" \
  || die "failed to create uploads directory"
install -dm755 "${HOME}/uploads/${user}" \
  || die "failed to create user's upload directory"

# when the client disconnects our parent dies and we recieve this signal
# so start the cleanup process
trap cleanup SIGHUP SIGTERM SIGINT

template="${HOME}/uploads/${user}/XXXXXXXX"
path=$(mktemp -d "${template}")
if (( $? != 0 )); then
  err "failed to create directory"
  exit 1
fi


msg "receiving files..."
bsdtar -C "${path}" -xvf - <&0 &
pid=$!
exec 0>&-
wait "${pid}"
if (( $? != 0 )); then
  err "failed to unpack received data"
  cleanup
  exit 1
fi

bail() {
  err "$@"
  cleanup
}

cd "${path}" || bail "failed to change to package directory"

repo_exists() {
  local repo="$1"
  if [[ ! -d "${repo_base}/${repo}/os" ]]; then
    err "no such repository: %s" "${repo}"
    false
  else
    true
  fi
}

check_access() {
  # currently we don't have such fine access controls
  :
}

push_package() {
  local repo="$1"
  local pkg="$2"

  local pkgname="${pkg%%-[0-9]*}"
  local archend="${pkg##*-}"
  local arch="${archend%%.*}"

  msg "package: %s for architecture %s" "${pkgname}" "${arch}"

}

msg "Pushing packages..."
for repo in *; do
  if ! repo_exists "${repo}"; then
    continue;
  fi
  if ! check_access "${repo}"; then
    continue;
  fi

  if pushd "${repo}" >/dev/null; then
    for pkg in *.pkg.tar.xz; do
      push_package "${repo}" "${pkg}"
    done
    popd >/dev/null || die "failed to enter previous directory"
  fi
done

msg "Functionality not implemented yet"
cleanup

# vim: set ts=2 sts=2 sw=2 et:
