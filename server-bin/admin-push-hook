#!/usr/bin/env perl

# update ~/.ssh/authorized_keys

# 'packagers' contains a list of ssh keys
# for users allowed to push to repositories

# 'core-group' can push to package repos as well as
# merge the [testing] repository to the rest

use strict;
use warnings;
use Fcntl qw(:flock);

my $HOME=$ENV{HOME};
my $authfile="${HOME}/.ssh/authorized_keys";
my $basefile="${HOME}/.ssh/admin_keys.pub";
my $newfile="${authfile}.new";

my $ssh_access="no-port-forwarding,no-X11-forwarding,no-agent-forwarding,no-pty";

# colorful!
sub mydie($@) {
  my ($mesg, @rest) = @_;
  printf STDERR "\033[1;35merror:\033[0;0m ${mesg}\n", @rest;
  exit(1);
}

##
# find a git blob object for a filename
# blob_for_file (filename)
#
sub blob_for_file($) {
  my ($file) = @_;

  my $ret = undef;

  open my $cmd, '-|', 'git ls-tree -r master';
  while (<$cmd>) {
    next unless /blob ([a-f0-9]{40})\s+${file}$/;
    $ret = $1;
    last;
  }
  close $cmd;
  return $ret;
}

##
# Handle a config line for regular packagers
# add_packager (out_handle, line)
#
sub add_packager($$) {
  my ($fh, $line) = @_;

  unless($line =~ m/^(\w+):\s*(.*)$/){
    print STDERR "invalid line: $line\n";
    return;
  }

  my $user=$1;
  my $key=$2;

  printf {$fh} "command=\"%s/bin/receive-package %s\",%s %s\n",
    $HOME, $user, $ssh_access, $key;
}

##
# Handle a config line from the 'core-group' file.
# add_admin (out_handle, line)
#
sub add_core($$) {
  my ($fh, $line) = @_;

  return add_packager($fh, $line);
}

##
# Handle a config line from the 'admin' file.
# add_admin (out_handle, line)
#
sub add_admin($$) {
  my ($fh, $line) = @_;

  print {$fh} "${line}\n";
}

##
# Execute a function for each non-empty non-comment line in a git file.
#
# for_file_line (out_handle, file_name, function)
#   out_handle    passed along as first parameter to <function>
#   file_name     the file in the current git-tree to read using blob_for_file
#   function      the function to execute for the file's lines
#                 function(out_handle, line)
#
sub for_file_line($$$) {
  my ($fh, $file, $func) = @_;

  my $blob = blob_for_file($file);
  if (defined($blob)) {
    open my $in, '-|', 'git', 'cat-file', 'blob', $blob;
    while (<$in>) {
      chomp; next if /^(?:#|$)/;
      $func->($fh, $_);
    }
    close $in;
  }
}

##
# Build the authorized_keys file from the current configuration files found
# in git.
#
# build_authorized_keys(out_handle)
#   out_handle    handle to the current authorized_keys.new
#
sub build_authorized_keys($) {
  my ($fh) = @_;

  # cat the basefile into fh
  open my $in, '<', $basefile;
  while (<$in>) {
    print {$fh} $_;
  }
  close $in;

  # process config files
  for_file_line($fh, 'admins',     \&add_admin);
  for_file_line($fh, 'packagers',  \&add_packager);
  for_file_line($fh, 'core-group', \&add_core);
}

##
# Main function doing all the cool work!
#
sub main() {
  open my $fh, '>', $newfile;
  flock($fh, LOCK_EX);
  build_authorized_keys($fh);
  rename($newfile, $authfile) or mydie("failed to replace authorization file");
  flock($fh, LOCK_UN);
  close($fh);
}

main();
